<!doctype html><html lang=en><meta charset=utf-8><meta name=generator content="Hugo 0.80.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content=Joway><meta property=og:url content=https://blog.joway.io/posts/golang-interface-internal/><link rel=canonical href=https://blog.joway.io/posts/golang-interface-internal/><link rel=dns-prefetch href=https://cdn.jsdelivr.net/gh/joway/blog><link rel=apple-touch-icon href=/logo.png><link rel=icon href=/logo.png><link rel=shortcut href=/logo.png><link rel=alternate type=application/atom+xml href=https://blog.joway.io/index.xml title="Joway's Blog"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.joway.io\/"},"articleSection":"posts","name":"Golang Interface 内部实现","headline":"Golang Interface 内部实现","description":"最近遇到一个由于 Golang Interface 底层实现，引发的线上 panic 问题，虽然根源在于赋值操作没有保护起来，却意外地发现了关于 interface 的一些有意思的底层细节。\n假设我们现在有以下定义：\ntype Interface interface { Run() } type Implement struct { n int } func (i *Implement) Run() { fmt.Printf(i.n) } 对于使用者而言，一个变量无论是 Interface 类型或是 *Implement 类型，差别都不大。\nfunc main() { var i Interface fmt.Printf(\u0026#34;%T\\n\u0026#34;, i) \/\/\u0026lt;nil\u0026gt;  i = \u0026amp;Implement{n: 1} fmt.Printf(\u0026#34;%T\\n\u0026#34;, i) \/\/*main.Implement  var p *Implement fmt.Printf(\u0026#34;%T\\n\u0026#34;, p) \/\/*main.Implement  p = \u0026amp;Implement{n: 1} fmt.Printf(\u0026#34;%T\\n\u0026#34;, p) \/\/*main.Implement } 如果现在有这么一段代码：\nfunc check(i Interface) { if i == nil { return } impl := i.","inLanguage":"en-US","author":"Joway","creator":"Joway","publisher":"Joway","accountablePerson":"Joway","copyrightHolder":"Joway","copyrightYear":"2021","datePublished":"2021-01-20 00:00:00 \u002b0000 UTC","dateModified":"2021-01-20 00:00:00 \u002b0000 UTC","url":"https:\/\/blog.joway.io\/posts\/golang-interface-internal\/","keywords":[]}</script><title>Golang Interface 内部实现 - Joway's Blog</title><meta property=og:title content="Golang Interface 内部实现 - Joway's Blog"><meta property=og:type content=article><meta property=og:description content='最近遇到一个由于 Golang Interface 底层实现，引发的线上 panic 问题，虽然根源在于赋值操作没有保护起来，却意外地发现了关于 interface 的一些有意思的底层细节。
假设我们现在有以下定义：
type Interface interface { Run() } type Implement struct { n int } func (i *Implement) Run() { fmt.Printf(i.n) } 对于使用者而言，一个变量无论是 Interface 类型或是 *Implement 类型，差别都不大。
func main() { var i Interface fmt.Printf("%T\n", i) //<nil>  i = &Implement{n: 1} fmt.Printf("%T\n", i) //*main.Implement  var p *Implement fmt.Printf("%T\n", p) //*main.Implement  p = &Implement{n: 1} fmt.Printf("%T\n", p) //*main.Implement } 如果现在有这么一段代码：
func check(i Interface) { if i == nil { return } impl := i.'><meta name=description content='最近遇到一个由于 Golang Interface 底层实现，引发的线上 panic 问题，虽然根源在于赋值操作没有保护起来，却意外地发现了关于 interface 的一些有意思的底层细节。
假设我们现在有以下定义：
type Interface interface { Run() } type Implement struct { n int } func (i *Implement) Run() { fmt.Printf(i.n) } 对于使用者而言，一个变量无论是 Interface 类型或是 *Implement 类型，差别都不大。
func main() { var i Interface fmt.Printf("%T\n", i) //<nil>  i = &Implement{n: 1} fmt.Printf("%T\n", i) //*main.Implement  var p *Implement fmt.Printf("%T\n", p) //*main.Implement  p = &Implement{n: 1} fmt.Printf("%T\n", p) //*main.Implement } 如果现在有这么一段代码：
func check(i Interface) { if i == nil { return } impl := i.'><meta property=og:locale content=en-us><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/joway/blog/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/index.css><link href=https://cdn.jsdelivr.net/gh/joway/blog/index.xml rel=alternate type=application/rss+xml title="Joway's Blog"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=UA-53624533-8"></script><script src=https://cdn.jsdelivr.net/gh/joway/homepage/analytics.js></script><article class="post 简体中文" id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>Joway Wang</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>Golang Interface 内部实现</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2021-01-20 00:00:00 UTC">20 Jan 2021</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://joway.io/>@Joway</a></div></div></div></header><div class="post-content markdown-body"><p>最近遇到一个由于 Golang Interface 底层实现，引发的线上 panic 问题，虽然根源在于赋值操作没有保护起来，却意外地发现了关于 interface 的一些有意思的底层细节。<p>假设我们现在有以下定义：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=color:#204a87;font-weight:700>type</span> <span style=color:#000>Interface</span> <span style=color:#204a87;font-weight:700>interface</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#000>Run</span><span style=color:#000;font-weight:700>()</span>
<span style=color:#000;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>type</span> <span style=color:#000>Implement</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#000>n</span> <span style=color:#204a87;font-weight:700>int</span>
<span style=color:#000;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>func</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>Implement</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000>Run</span><span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#000>fmt</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>n</span><span style=color:#000;font-weight:700>)</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>对于使用者而言，一个变量无论是 <code>Interface</code> 类型或是 <code>*Implement</code> 类型，差别都不大。<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>var</span> <span style=color:#000>i</span> <span style=color:#000>Interface</span>
    <span style=color:#000>fmt</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;%T\n&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>i</span><span style=color:#000;font-weight:700>)</span> <span style=color:#8f5902;font-style:italic>//&lt;nil&gt;
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#000>i</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>&amp;</span><span style=color:#000>Implement</span><span style=color:#000;font-weight:700>{</span><span style=color:#000>n</span><span style=color:#000;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>}</span>
    <span style=color:#000>fmt</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;%T\n&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>i</span><span style=color:#000;font-weight:700>)</span> <span style=color:#8f5902;font-style:italic>//*main.Implement
</span><span style=color:#8f5902;font-style:italic></span>
    <span style=color:#204a87;font-weight:700>var</span> <span style=color:#000>p</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>Implement</span>
    <span style=color:#000>fmt</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;%T\n&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>p</span><span style=color:#000;font-weight:700>)</span> <span style=color:#8f5902;font-style:italic>//*main.Implement
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#000>p</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>&amp;</span><span style=color:#000>Implement</span><span style=color:#000;font-weight:700>{</span><span style=color:#000>n</span><span style=color:#000;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>}</span>
    <span style=color:#000>fmt</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;%T\n&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>p</span><span style=color:#000;font-weight:700>)</span> <span style=color:#8f5902;font-style:italic>//*main.Implement
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>如果现在有这么一段代码：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>check</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span> <span style=color:#000>Interface</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#204a87;font-weight:700>nil</span> <span style=color:#000;font-weight:700>{</span>
        <span style=color:#204a87;font-weight:700>return</span>
    <span style=color:#000;font-weight:700>}</span>
    <span style=color:#000>impl</span> <span style=color:#ce5c00;font-weight:700>:=</span> <span style=color:#000>i</span><span style=color:#000;font-weight:700>.(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>Implement</span><span style=color:#000;font-weight:700>)</span>
    <span style=color:#000>fmt</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Println</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>impl</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>n</span><span style=color:#000;font-weight:700>)</span> <span style=color:#8f5902;font-style:italic>//Invalid memory address or nil pointer dereference
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>这段代码从逻辑上来说，<code>impl.n</code> 永远都不会报空指针异常，因为 i 如果为空就会提前返回了。而且就算 i 为 nil，在 <code>impl := i.(*Implement)</code> 类型转换的时候就会直接 panic，而不是在下一行。但在线上环境上却的确在 <code>impl.n</code> 位置报了错误。<p>在探究了 interface 底层实现后发现，在上面的 main 函数的例子里，i 和 p 虽然在使用方式上是一致的，但在内部存储的结构体却是不同的。<code>*Implement</code> 类型内部存储的是一个指针，对他赋值也只是赋予一个指针。而 <code>Interface</code> 接口底层结构却是一个类型为 <code>iface</code> 的 struct ：<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=color:#204a87;font-weight:700>type</span> <span style=color:#000>iface</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#000>tab</span>  <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>itab</span>
    <span style=color:#000>data</span> <span style=color:#000>unsafe</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Pointer</span>
<span style=color:#000;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>type</span> <span style=color:#000>itab</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#000>inter</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>interfacetype</span>
    <span style=color:#000>_type</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>_type</span>
    <span style=color:#000>hash</span>  <span style=color:#204a87;font-weight:700>uint32</span> <span style=color:#8f5902;font-style:italic>// copy of _type.hash. Used for type switches.
</span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#000>_</span>     <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>]</span><span style=color:#204a87;font-weight:700>byte</span>
    <span style=color:#000>fun</span>   <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>]</span><span style=color:#204a87;font-weight:700>uintptr</span> <span style=color:#8f5902;font-style:italic>// variable sized. fun[0]==0 means _type does not implement inter.
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>当对一个接口赋值时，即对该 struct 的 <code>tab</code> 与 <code>data</code> 字段分别赋值。而该操作并非是原子性的，有可能赋值到一半，也就是 <code>.tab</code> 有值而 <code>.data</code> 为空时，就被另一个 goroutine 抢走，并进行 <code>!= nil</code> 的判断。而 golang 却只有在 <code>iface</code> 两个属性同时为 nil 时候才认为是 nil，所以 check 函数内的 if 条件判断失效。<p>同时由于 <code>.tab</code> 内已经有了类型信息，所以在 <code>impl := i.(*Implement)</code> 类型转换的时候也能够成功转换，并不会报空指针错误，即便该 interface 的 <code>.data</code> 字段是 nil 。只有当实际去调用 <code>impl.n</code> 的时候，才会发现 <code>.data</code> 为 nil，从而 panic。</div><div class="row middle-xs"><div class=col-xs-12><div class=post-category><a href=/categories/tech/>Tech</a></div></div></div><div class=row><div class=col-xs-12><br><br><p>Subscribe：<a target=_blank href=https://mailchi.mp/a1a0d59e7a19/joway><b>Mailchimp</b></a></p><br><a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/><img alt="Creative Commons License" style=border-width:0 src=https://blog.joway.io/images/cc.png></a></div></div><div style=height:50px></div><div class=post-comments><div id=disqus_thread></div><script>window.addEventListener("load",()=>{(function(){var d=document,s=d.createElement("script");s.src="https://joway.disqus.com/embed.js";s.setAttribute("data-timestamp",+new Date());(d.head||d.body).appendChild(s);})();});</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div><div class=site-footer><div class=site-footer-item><a href=https://mailchi.mp/a1a0d59e7a19/joway target=_blank>Subscribe</a></div><div class=site-footer-item><a href=/index.xml target=_blank>RSS</a></div><div class=site-footer-item><a href=/presentations target=_blank>Slides</a></div><div class=site-footer-item><a href=/travel target=_blank>Travel</a></div><div class=site-footer-item><a href=https://joway.io target=_blank>About</a></div></div></div></div></article><script src=https://cdn.jsdelivr.net/gh/joway/blog/js/highlight.pack.js></script><script src=https://cdn.jsdelivr.net/gh/joway/blog/js/lazyload.min.js></script><script>var lazyImage=new LazyLoad({container:document.getElementById('article')});</script>