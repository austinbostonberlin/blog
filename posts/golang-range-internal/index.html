<!doctype html><html lang=en><meta charset=utf-8><meta name=generator content="Hugo 0.80.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content=Joway><meta property=og:url content=https://blog.joway.io/posts/golang-range-internal/><link rel=canonical href=https://blog.joway.io/posts/golang-range-internal/><link rel=dns-prefetch href=https://cdn.jsdelivr.net/gh/joway/blog><link rel=apple-touch-icon href=/logo.png><link rel=icon href=/logo.png><link rel=shortcut href=/logo.png><link rel=alternate type=application/atom+xml href=https://blog.joway.io/index.xml title="Joway's Blog"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.joway.io\/"},"articleSection":"posts","name":"Golang for-range 内部实现","headline":"Golang for-range 内部实现","description":"最近在写一个编解码的功能时发现使用 Golang for-range 会存在很大的性能问题。\n假设我们现在有一个 Data 类型表示一个数据包，我们从网络中获取到了 [1024]Data 个数据包，此时我们需要对其进行遍历操作。一般我们会使用 for-i\u002b\u002b 或者 for-range 两种方式遍历，如下代码：\ntype Data [256]byte func BenchmarkForStruct(b *testing.B) { var items [1024]Data var result Data for i := 0; i \u0026lt; b.N; i\u002b\u002b { for k := 0; k \u0026lt; len(items); k\u002b\u002b { result = items[k] } } _ = result } func BenchmarkRangeStruct(b *testing.B) { var items [1024]Data var result Data for i := 0; i \u0026lt; b.N; i\u002b\u002b { for _, item := range items { result = item } } _ = result } 输出结果：","inLanguage":"en-US","author":"Joway","creator":"Joway","publisher":"Joway","accountablePerson":"Joway","copyrightHolder":"Joway","copyrightYear":"2021","datePublished":"2021-01-20 00:00:00 \u002b0000 UTC","dateModified":"2021-01-20 00:00:00 \u002b0000 UTC","url":"https:\/\/blog.joway.io\/posts\/golang-range-internal\/","keywords":[]}</script><title>Golang for-range 内部实现 - Joway's Blog</title><meta property=og:title content="Golang for-range 内部实现 - Joway's Blog"><meta property=og:type content=article><meta property=og:description content="最近在写一个编解码的功能时发现使用 Golang for-range 会存在很大的性能问题。
假设我们现在有一个 Data 类型表示一个数据包，我们从网络中获取到了 [1024]Data 个数据包，此时我们需要对其进行遍历操作。一般我们会使用 for-i++ 或者 for-range 两种方式遍历，如下代码：
type Data [256]byte func BenchmarkForStruct(b *testing.B) { var items [1024]Data var result Data for i := 0; i < b.N; i++ { for k := 0; k < len(items); k++ { result = items[k] } } _ = result } func BenchmarkRangeStruct(b *testing.B) { var items [1024]Data var result Data for i := 0; i < b.N; i++ { for _, item := range items { result = item } } _ = result } 输出结果："><meta name=description content="最近在写一个编解码的功能时发现使用 Golang for-range 会存在很大的性能问题。
假设我们现在有一个 Data 类型表示一个数据包，我们从网络中获取到了 [1024]Data 个数据包，此时我们需要对其进行遍历操作。一般我们会使用 for-i++ 或者 for-range 两种方式遍历，如下代码：
type Data [256]byte func BenchmarkForStruct(b *testing.B) { var items [1024]Data var result Data for i := 0; i < b.N; i++ { for k := 0; k < len(items); k++ { result = items[k] } } _ = result } func BenchmarkRangeStruct(b *testing.B) { var items [1024]Data var result Data for i := 0; i < b.N; i++ { for _, item := range items { result = item } } _ = result } 输出结果："><meta property=og:locale content=en-us><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/joway/blog/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/index.css><link href=https://cdn.jsdelivr.net/gh/joway/blog/index.xml rel=alternate type=application/rss+xml title="Joway's Blog"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=UA-53624533-8"></script><script src=https://cdn.jsdelivr.net/gh/joway/homepage/analytics.js></script><article class="post 简体中文" id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>Joway Wang</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>Golang for-range 内部实现</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2021-01-20 00:00:00 UTC">20 Jan 2021</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://joway.io/>@Joway</a></div></div></div></header><div class="post-content markdown-body"><p>最近在写一个编解码的功能时发现使用 Golang <code>for-range</code> 会存在很大的性能问题。<p>假设我们现在有一个 <code>Data</code> 类型表示一个数据包，我们从网络中获取到了 <code>[1024]Data</code> 个数据包，此时我们需要对其进行遍历操作。一般我们会使用 for-i++ 或者 for-range 两种方式遍历，如下代码：<div class=highlight><pre style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=font-weight:700>type</span> Data [256]<span>byte</span>

<span style=font-weight:700>func</span> BenchmarkForStruct(b *testing.B) {
	<span style=font-weight:700>var</span> items [1024]Data
	<span style=font-weight:700>var</span> result Data
	<span style=font-weight:700>for</span> i := 0; i &lt; b.N; i++ {
		<span style=font-weight:700>for</span> k := 0; k &lt; len(items); k++ {
			result = items[k]
		}
	}
	_ = result
}

<span style=font-weight:700>func</span> BenchmarkRangeStruct(b *testing.B) {
	<span style=font-weight:700>var</span> items [1024]Data
	<span style=font-weight:700>var</span> result Data
	<span style=font-weight:700>for</span> i := 0; i &lt; b.N; i++ {
		<span style=font-weight:700>for</span> _, item := <span style=font-weight:700>range</span> items {
			result = item
		}
	}
	_ = result
}
</code></pre></div><p>输出结果：<div class=highlight><pre style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback>BenchmarkForStruct-8     	 1697805	       652 ns/op
BenchmarkRangeStruct-8   	   60556	     19837 ns/op
</code></pre></div><p>可以看到通过索引来遍历的方式要比直接使用 for-range 快了近 30 倍。<p>索引遍历就是单纯地去访问数组的每个元素。而对于 for-range 循环，Golang 会根据迭代对象类型，已经 range 前的参数，对其进行不同形式的展开。对于以下 range 代码：<div class=highlight><pre style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=font-weight:700>for</span> i, elem := <span style=font-weight:700>range</span> a {}
</code></pre></div><p>编译器会将其转换成如下形式（伪代码）, <a href=https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/range.go#L216>range.go</a>：<div class=highlight><pre style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-golang data-lang=golang>ha := a <span style=font-style:italic>// 值拷贝
</span><span style=font-style:italic></span>hn := len(ha) <span style=font-style:italic>// 提前保存长度
</span><span style=font-style:italic></span>hv1 := 0 <span style=font-style:italic>// 当前遍历索引值
</span><span style=font-style:italic></span>v1 := hv1 <span style=font-style:italic>// 保存当前索引
</span><span style=font-style:italic></span>v2 := <span style=font-weight:700>nil</span> <span style=font-style:italic>// 保存当前值
</span><span style=font-style:italic></span><span style=font-weight:700>for</span> ; hv1 &lt; hn; hv1++ {
    v1, v2 = hv1, ha[hv1] <span style=font-style:italic>// 值拷贝
</span><span style=font-style:italic></span>    ...
}
</code></pre></div><p>这里有几点需要额外注意：<ol><li>编译器提前保存了元素长度，所以运行过程中即便长度变化，也不会影响循环次数<li><code>ha := a</code> 这一步会进行一次值拷贝，这里部分情况下可能会存在性能问题 （如上面的 [256]byte 类型，每次拷贝都有很大内存开销）<li><code>v1, v2 = hv1, ha[hv1]</code> 会对数组元素进行一次值拷贝<li>v1, v2 预先创建，地址不会改变，对应到原始代码就是 <code>for i, elem := range a {}</code> 中的 <code>i, elem</code> 在每次循环时，都是同一个变量。</ol><p>由此可以发现，当被迭代对象的元素为拷贝开销较大的类型时，使用 for-range 循环会存在很大的性能问题。此时更加建议使用标准 for 循环。</div><div class="row middle-xs"><div class=col-xs-12><div class=post-category><a href=/categories/tech/>Tech</a></div></div></div><div class=row><div class=col-xs-12><br><br><p>Subscribe：<a target=_blank href=https://mailchi.mp/a1a0d59e7a19/joway><b>Mailchimp</b></a></p><br><a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/><img alt="Creative Commons License" style=border-width:0 src=https://blog.joway.io/images/cc.png></a></div></div><div style=height:50px></div><div class=post-comments><div id=disqus_thread></div><script>window.addEventListener("load",()=>{(function(){var d=document,s=d.createElement("script");s.src="https://joway.disqus.com/embed.js";s.setAttribute("data-timestamp",+new Date());(d.head||d.body).appendChild(s);})();});</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div><div class=site-footer><div class=site-footer-item><a href=https://mailchi.mp/a1a0d59e7a19/joway target=_blank>Subscribe</a></div><div class=site-footer-item><a href=/index.xml target=_blank>RSS</a></div><div class=site-footer-item><a href=/presentations target=_blank>Slides</a></div><div class=site-footer-item><a href=/travel target=_blank>Travel</a></div><div class=site-footer-item><a href=https://joway.io target=_blank>About</a></div></div></div></div></article><script src=https://cdn.jsdelivr.net/gh/joway/blog/js/highlight.pack.js></script><script src=https://cdn.jsdelivr.net/gh/joway/blog/js/lazyload.min.js></script><script>var lazyImage=new LazyLoad({container:document.getElementById('article')});</script>