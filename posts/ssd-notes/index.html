<!doctype html><html lang=en><meta charset=utf-8><meta name=generator content="Hugo 0.62.2"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content=Joway><meta property=og:url content=https://blog.joway.io/posts/ssd-notes/><link rel=canonical href=https://blog.joway.io/posts/ssd-notes/><link rel="shortcut icon" href=/logo.png type=image/x-png><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.joway.io\/"},"articleSection":"posts","name":"SSD 背后的奥秘","headline":"SSD 背后的奥秘","description":"过去很长一段时间里，我对 SSD 的了解仅限于其和 HDD 的区别和一个标签化的「速度快」认知，至于其什么时候快，为什么快却鲜有了解。直到最近开始研究数据库时，发现数据库设计和存储发展和特性紧密联系，不可分割，于是才开始回过头关注起 SSD 的结构和原理，猛然发现之前关于 SSD 有许多非常错误的认识。\nSSD 的基本结构 在了解 SSD 性质前，简单回顾下 SSD 的基本结构组成，下面是两张 SSD 的架构图：\n其中，SSD Controller 用以执行耗损平衡、垃圾回收、坏快映射、错误检查纠正、加密等功能。相比与 HDD，它的工作非常繁重，而这些工作极大地影响了 SSD 的性能表现，后文会详细谈到。SSD 内部的闪存（Flash）由一个个闪存单元组成，每个闪存单元都有一个寿命，超过寿命将导致坏块。常见有三种闪存单元类型：\n SLC：每个单元 1 比特 MLC：每个单元 2 比特 TLC：每个单元 3 比特  每种 NAND 类型有不同的性能和寿命表现，如下表：\n闪存单元内部由一个个 Block 组成，每个 Block 由多个 Page 组成。\n对于闪存的访问有以下限制：\n 读写数据只能以 Page 为单位 擦除数据只能以 Block 为单位  每个 Page 大小一般为 2 KB 到 16 KB，这意味着使用 SSD 时，哪怕读或写 1 Byte 的数据，SSD 依旧会访问整个 Page。","inLanguage":"en-US","author":"Joway","creator":"Joway","publisher":"Joway","accountablePerson":"Joway","copyrightHolder":"Joway","copyrightYear":"2019","datePublished":"2019-07-09 00:00:00 \x2b0000 UTC","dateModified":"2019-07-09 00:00:00 \x2b0000 UTC","url":"https:\/\/blog.joway.io\/posts\/ssd-notes\/","keywords":[]}</script><title>SSD 背后的奥秘 - Joway's Blog</title><meta property=og:title content="SSD 背后的奥秘 - Joway's Blog"><meta property=og:type content=article><meta name=description content="过去很长一段时间里，我对 SSD 的了解仅限于其和 HDD 的区别和一个标签化的「速度快」认知，至于其什么时候快，为什么快却鲜有了解。直到最近开始研究数据库时，发现数据库设计和存储发展和特性紧密联系，不可分割，于是才开始回过头关注起 SSD 的结构和原理，猛然发现之前关于 SSD 有许多非常错误的认识。
SSD 的基本结构 在了解 SSD 性质前，简单回顾下 SSD 的基本结构组成，下面是两张 SSD 的架构图：
其中，SSD Controller 用以执行耗损平衡、垃圾回收、坏快映射、错误检查纠正、加密等功能。相比与 HDD，它的工作非常繁重，而这些工作极大地影响了 SSD 的性能表现，后文会详细谈到。SSD 内部的闪存（Flash）由一个个闪存单元组成，每个闪存单元都有一个寿命，超过寿命将导致坏块。常见有三种闪存单元类型：
 SLC：每个单元 1 比特 MLC：每个单元 2 比特 TLC：每个单元 3 比特  每种 NAND 类型有不同的性能和寿命表现，如下表：
闪存单元内部由一个个 Block 组成，每个 Block 由多个 Page 组成。
对于闪存的访问有以下限制：
 读写数据只能以 Page 为单位 擦除数据只能以 Block 为单位  每个 Page 大小一般为 2 KB 到 16 KB，这意味着使用 SSD 时，哪怕读或写 1 Byte 的数据，SSD 依旧会访问整个 Page。"><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/joway/blog/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/joway/blog/css/github-markdown.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/joway/blog/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=https://cdn.jsdelivr.net/gh/joway/blog/index.xml rel=alternate type=application/rss+xml title="Joway's Blog"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=UA-53624533-8"></script><script src=https://cdn.jsdelivr.net/gh/joway/homepage/analytics.js></script><article class="post 简体中文" id=article><div class=row><div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2 col-lg-6 col-lg-offset-3"><div class=site-header><header><div class="signatures site-title"><a href=/>Joway Wang</a></div></header><div class="row end-xs"><div class="lang-switch col-xs-3 col-xs-offset-9"><a href=/en/>English</a></div></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>SSD 背后的奥秘</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2019-07-09 00:00:00 UTC">09 Jul 2019</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://joway.io/>@Joway</a></div></div></div></header><div class="post-content markdown-body"><p>过去很长一段时间里，我对 SSD 的了解仅限于其和 HDD 的区别和一个标签化的「速度快」认知，至于其什么时候快，为什么快却鲜有了解。直到最近开始研究数据库时，发现数据库设计和存储发展和特性紧密联系，不可分割，于是才开始回过头关注起 SSD 的结构和原理，猛然发现之前关于 SSD 有许多非常错误的认识。<h2 id=ssd-的基本结构>SSD 的基本结构</h2><p>在了解 SSD 性质前，简单回顾下 SSD 的基本结构组成，下面是两张 SSD 的架构图：<p><img src=/images/ssd-architecture.jpg alt>
<img src=/images/samsungssd840pro.jpg alt><p>其中，SSD Controller 用以执行耗损平衡、垃圾回收、坏快映射、错误检查纠正、加密等功能。相比与 HDD，它的工作非常繁重，而这些工作极大地影响了 SSD 的性能表现，后文会详细谈到。SSD 内部的闪存（Flash）由一个个闪存单元组成，每个闪存单元都有一个寿命，超过寿命将导致坏块。常见有三种闪存单元类型：<ul><li>SLC：每个单元 1 比特<li>MLC：每个单元 2 比特<li>TLC：每个单元 3 比特</ul><p>每种 NAND 类型有不同的性能和寿命表现，如下表：<p><img src=/images/nand-type-table.png alt><p>闪存单元内部由一个个 Block 组成，每个 Block 由多个 Page 组成。<p><img src=/images/ssd_nand_flash.png alt><p>对于闪存的访问有以下限制：<ul><li>读写数据只能以 Page 为单位<li>擦除数据只能以 Block 为单位</ul><p>每个 Page 大小一般为 2 KB 到 16 KB，这意味着使用 SSD 时，哪怕读或写 1 Byte 的数据，SSD 依旧会访问整个 Page。<p>此外，SSD 并不允许覆盖的操作，当原本 Page 中已有数据时，只能先删除再写入，为了加快写入速度，一般 SSD 修改数据时，会先写入其他空闲页，再将原始页标记为 stale ，直到最终被垃圾回收擦除。<h2 id=ssd-内部工作细节>SSD 内部工作细节</h2><h3 id=垃圾回收>垃圾回收</h3><p>SSD 在擦除整个 Block 时，需要先整理其中的 Page，腾出没有活跃 Page 的 Block 进行擦除。此过程中，原本的一次写入最终有可能会隐式牵涉到多个 Page 的移动，导致出现写入放大的现象。因此垃圾回收是一个耗时且容易影响寿命操作。<p>垃圾回收一般是一个后台操作，但当出现写入速度超过了回收速度时，SSD 会启动前台垃圾回收，此时必须等待待写入 Block 被擦除才能继续写入，从而严重影响写入延迟。<p>由于垃圾回收的存在，我们可以发现，频繁地修改一个文件是不利于 SSD 寿命和性能表现的。<p><img src=/images/ssd-writing-data.jpg alt><h3 id=逻辑地址转换>逻辑地址转换</h3><p>SSD 内部会维护一个逻辑地址到物理地址的映射。程序不需要关心物理地址，由 SSD 的 FTL （Flash Translation Layer）进行映射转换。<p>这样做的好处是，对于应用程序来说，文件地址依旧是连续的，而真实存储的时候可以由 FTL 算法决定分配到哪些空闲页上。<h3 id=损耗均衡>损耗均衡</h3><p>NAND 内存单元存在 P/E 循环限制，所以都会有一个固定的寿命。如果出现热点块反复写入数据，很快这个块的寿命就会耗尽，导致容量变小。由于有了前面的逻辑地址转换，所以物理地址可以由 SSD Controller 控制映射关系，从而可以实现损耗均衡。SSD Controller 会平均利用每个 Block 的寿命，使得各个 Block 的寿命在同一时间达到他们的 P/E 循环限制而耗尽。<h3 id=断电保护>断电保护</h3><p>一些 SSD 中设有超级电容，这个电容设计为存有足够提交总线中所有 I/O 请求所需的能量以防掉电丢失数据。<h3 id=ssd-并行处理>SSD 并行处理</h3><p>SSD 有四种层次的并行处理方式：<ul><li>Channel-level parallelism<li>Package-level parallelism<li>Chip-level parallelism<li>Plane-level parallelism</ul><p><img src=/images/ssd-package.jpg alt><p>SSD 内部将不同芯片中的多个 Block 组成一个 Clustered Block。单次数据写入可以通过 Clustered Block 并行写入到不同 Block 中。由此可以发现，即便是单线程的写入，在 SSD 层也能实现并发的写，当然前提是写入的数据大于整个 Clustered Block 的大小。另外，对于这类大数据的写入，单线程性能甚至优于多线程，多线程写入会有更大的延迟。<h2 id=如何正确读写-ssd>如何正确读写 SSD</h2><h3 id=了解访问模式>了解访问模式</h3><h4 id=定义>定义</h4><ul><li>如果 I/O 操作开始的逻辑块地址（LBA）直接跟着前一个 I/O 操作的最后LBA，则称值为<strong>顺序访问</strong><li>如果不是这样，那这个I/O操作称为<strong>随机访问</strong></ul><h4 id=不同访问模式的速度>不同访问模式的速度</h4><p>通常来说，即便是对于 SSD，随机读写也会比顺序读写要慢很多，最恶劣情况下甚至相差10倍。<p><img src=/images/lies-damn-lies-and-ssd-benchmark.jpg alt><p>随机读的问题在于：<ol><li>不能利用预读功能提前缓存数据<li>每次 IO 需要重新定位物理地址</ol><p>随机写的问题在于：<ol><li>造成大量磁盘碎片，极大地增加了垃圾回收的压力<li>小数据量的随机写无法利用 SSD 内置的并发能力</ol><p>但是如果随机写入能够按照 Clustered Block 大小对齐，那么利用 SSD 并行的能力，随机写入能够达到和顺序写入同样的吞吐量。<p>如果仔细观察上图还会发现在一开始无论是随机读写还是顺序读写，性能都非常高，这是因为一开始所有 Page 都是空闲的，完全不需要垃圾回收，所以两者表现差异不大，但当磁盘被写满过一次以后，垃圾回收的压力使得随机读写性能一落千丈。这也是为什么 SSD 一买来测试速度会表现非常好，而之后越来越慢的原因。<h3 id=和-hdd-的区别>和 HDD 的区别</h3><p>对于 HDD，修改一个数据并不需要进行「读取-擦除-写入」的过程，而是可以直接就地（in-place）更新，所以许多许多数据结构被设计成 in-place 的方式，但对于 SSD 这种更新会给垃圾回收带来巨大负担，既影响寿命也影响性能。<h3 id=按读方式设计写方式>按读方式设计写方式</h3><p>对于一些经常被一起访问的数据（如关系型数据的单条记录），写时最好一次同时写入，这样做的好处是：<ol><li>如果能够在单 Page 内容纳下，读取时只读取单 Page<li>如果需要多个 Page 才能容纳，写入时会并行写入到 Clustered Block，读取时也能一次并行读取</ol><h3 id=冷热分离读写>冷热分离读写</h3><p>如果有一行记录：<pre><code>name,birthday,visted_count
</code></pre><p>由于这行数据非常小，所以基本会落到同一个 Page 上，而 <code>visted_count</code> 这个值是一个典型的热数据，<code>name,birthday</code> 是典型的冷数据，此时每次用户访问时去更新 <code>visted_count</code> 都会导致整个 Page 的数据被挪动和重写。<p>对于这类不得不变更的热数据，好的做法是先放在内存中，定期刷盘，从而避免频繁修改磁盘。<h3 id=使用单线程进行大写入读取>使用单线程进行大写入/读取</h3><p>大 IO 能够充分利用 SSD 并行特性，读写延迟更短。</div><div class="row middle-xs"><div class=col-xs-12><div class=post-category><a href=/categories/%e6%8a%80%e6%9c%af/>技术</a></div></div></div><div class=post-ads><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-6400651395935595 data-ad-slot=5705651853 data-ad-format=auto data-full-width-responsive=true></ins></div><div style=height:50px></div><div class=post-comments><div id=disqus_thread></div><script>window.addEventListener("load",()=>{(function(){var d=document,s=d.createElement("script");s.src="https://joway.disqus.com/embed.js";s.setAttribute("data-timestamp",+new Date());(d.head||d.body).appendChild(s);})();});</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div><div class=site-footer><div class=site-footer-item><a href=https://jstore.codefuture.top/store/5e01cf5945988500186a551e target=_blank>Buy</a></div><div class=site-footer-item><a href=/index.xml target=_blank>RSS</a></div><div class=site-footer-item><a href=/travel target=_blank>Map</a></div><div class=site-footer-item><a href=/cat target=_blank>Kui.Cat</a></div><div class=site-footer-item><a href=https://joway.io target=_blank>About</a></div></div></div></div></article><script src=https://cdn.jsdelivr.net/gh/joway/blog/js/highlight.pack.js></script><script src=https://cdn.jsdelivr.net/gh/joway/blog/js/lazyload.min.js></script><script>var lazyImage=new LazyLoad({container:document.getElementById('article')});</script><script>hljs.initHighlightingOnLoad();</script><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script>