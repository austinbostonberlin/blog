<!doctype html><html lang=en><meta charset=utf-8><meta name=generator content="Hugo 0.65.3"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content=Joway><meta property=og:url content=https://blog.joway.io/posts/nodejs-debug/><link rel=canonical href=https://blog.joway.io/posts/nodejs-debug/><link rel=apple-touch-icon href=/logo.png><link rel=icon href=/logo.png><link rel=shortcut href=/logo.png><link rel=alternate type=application/atom+xml href=https://blog.joway.io/index.xml title="Joway's Blog"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.joway.io\/"},"articleSection":"posts","name":"NodeJS 内存泄漏检测与定位","headline":"NodeJS 内存泄漏检测与定位","description":"最近解决了一个 Node.JS 应用内存泄漏 Bug，顺便学会了用 Chrome DevTools 去看 heapdump 文件。这里做一些简单的记录。\n如何「优雅地」获得 heapdump 文件 由于我们所有应用都是以容器部署的，所以要去获得某个容器内的文件，并拷贝到本地难度还是比较大，也非常麻烦。考虑到调试时或许会需要下载非常多次的 snapshot 文件，建议可以包下 heapdump 库，做成一个接口，把文件 dump 之后再传输给客户端，这样一劳永逸。\n需要小心的是，在 heapdump 的时候内存很容易翻倍，所以当内存超过 500 MB的时候如果去 heapdump 非常容易导致 OOM 从而 Crash。\n如何检测内存泄漏 检查内存泄漏有两种方法，一种是针对比较大的内存泄漏可以直接观察内存是否一直在稳步上升。如果是一些小的泄漏使得内存上升变化并不非常明显的话，可以通过对比不同时间的 heapdump 文件。\n有时候内存上升也可能是因为本身访问量就在上升，所以需要两者对比着分析。\nHeapdump 文件对比 通过下载两份间隔一段时间(几分钟)的 heapdump 文件，打开 Chrome DevTools，进入 Memory Tab，选择 Load。选中其中时间更近的 heapdump ，并选择 Comparison，比较对象是老的那份 heapdump：\n此时可以选择按 Delta 排序，可以看到两个时间点增加了哪些新的对象。\n如图可以看到 string 和 Object 的 Delta 是差不多的，所以可以比较确定是由于 Object 里产生了大量一些 string 对象导致的数量增多，但并不一定能够100%确定是内存泄漏，也可能是正常业务波动。此时需要再拉新的一个时间点的 heapdump 文件再来对比，如果一直在增加，那么内存泄漏的可能性就非常大了。\n如何定位内存泄漏 首先依旧是拿到 heapdump 文件，并在 Chrome 中打开。","inLanguage":"en-US","author":"Joway","creator":"Joway","publisher":"Joway","accountablePerson":"Joway","copyrightHolder":"Joway","copyrightYear":"2019","datePublished":"2019-11-10 00:00:00 \x2b0000 UTC","dateModified":"2019-11-10 00:00:00 \x2b0000 UTC","url":"https:\/\/blog.joway.io\/posts\/nodejs-debug\/","keywords":[]}</script><title>NodeJS 内存泄漏检测与定位 - Joway's Blog</title><meta property=og:title content="NodeJS 内存泄漏检测与定位 - Joway's Blog"><meta property=og:type content=article><meta property=og:description content="最近解决了一个 Node.JS 应用内存泄漏 Bug，顺便学会了用 Chrome DevTools 去看 heapdump 文件。这里做一些简单的记录。
如何「优雅地」获得 heapdump 文件 由于我们所有应用都是以容器部署的，所以要去获得某个容器内的文件，并拷贝到本地难度还是比较大，也非常麻烦。考虑到调试时或许会需要下载非常多次的 snapshot 文件，建议可以包下 heapdump 库，做成一个接口，把文件 dump 之后再传输给客户端，这样一劳永逸。
需要小心的是，在 heapdump 的时候内存很容易翻倍，所以当内存超过 500 MB的时候如果去 heapdump 非常容易导致 OOM 从而 Crash。
如何检测内存泄漏 检查内存泄漏有两种方法，一种是针对比较大的内存泄漏可以直接观察内存是否一直在稳步上升。如果是一些小的泄漏使得内存上升变化并不非常明显的话，可以通过对比不同时间的 heapdump 文件。
有时候内存上升也可能是因为本身访问量就在上升，所以需要两者对比着分析。
Heapdump 文件对比 通过下载两份间隔一段时间(几分钟)的 heapdump 文件，打开 Chrome DevTools，进入 Memory Tab，选择 Load。选中其中时间更近的 heapdump ，并选择 Comparison，比较对象是老的那份 heapdump：
此时可以选择按 Delta 排序，可以看到两个时间点增加了哪些新的对象。
如图可以看到 string 和 Object 的 Delta 是差不多的，所以可以比较确定是由于 Object 里产生了大量一些 string 对象导致的数量增多，但并不一定能够100%确定是内存泄漏，也可能是正常业务波动。此时需要再拉新的一个时间点的 heapdump 文件再来对比，如果一直在增加，那么内存泄漏的可能性就非常大了。
如何定位内存泄漏 首先依旧是拿到 heapdump 文件，并在 Chrome 中打开。"><meta name=description content="最近解决了一个 Node.JS 应用内存泄漏 Bug，顺便学会了用 Chrome DevTools 去看 heapdump 文件。这里做一些简单的记录。
如何「优雅地」获得 heapdump 文件 由于我们所有应用都是以容器部署的，所以要去获得某个容器内的文件，并拷贝到本地难度还是比较大，也非常麻烦。考虑到调试时或许会需要下载非常多次的 snapshot 文件，建议可以包下 heapdump 库，做成一个接口，把文件 dump 之后再传输给客户端，这样一劳永逸。
需要小心的是，在 heapdump 的时候内存很容易翻倍，所以当内存超过 500 MB的时候如果去 heapdump 非常容易导致 OOM 从而 Crash。
如何检测内存泄漏 检查内存泄漏有两种方法，一种是针对比较大的内存泄漏可以直接观察内存是否一直在稳步上升。如果是一些小的泄漏使得内存上升变化并不非常明显的话，可以通过对比不同时间的 heapdump 文件。
有时候内存上升也可能是因为本身访问量就在上升，所以需要两者对比着分析。
Heapdump 文件对比 通过下载两份间隔一段时间(几分钟)的 heapdump 文件，打开 Chrome DevTools，进入 Memory Tab，选择 Load。选中其中时间更近的 heapdump ，并选择 Comparison，比较对象是老的那份 heapdump：
此时可以选择按 Delta 排序，可以看到两个时间点增加了哪些新的对象。
如图可以看到 string 和 Object 的 Delta 是差不多的，所以可以比较确定是由于 Object 里产生了大量一些 string 对象导致的数量增多，但并不一定能够100%确定是内存泄漏，也可能是正常业务波动。此时需要再拉新的一个时间点的 heapdump 文件再来对比，如果一直在增加，那么内存泄漏的可能性就非常大了。
如何定位内存泄漏 首先依旧是拿到 heapdump 文件，并在 Chrome 中打开。"><meta property=og:locale content=en-us><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/joway/blog/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/joway/blog/css/github-markdown.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/joway/blog/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=https://cdn.jsdelivr.net/gh/joway/blog/index.xml rel=alternate type=application/rss+xml title="Joway's Blog"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=UA-53624533-8"></script><script src=https://cdn.jsdelivr.net/gh/joway/homepage/analytics.js></script><article class="post 简体中文" id=article><div class=row><div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2 col-lg-6 col-lg-offset-3"><div class=site-header><header><div class="signatures site-title"><a href=/>Joway Wang</a></div></header><div class="row end-xs"><div class="lang-switch col-xs-3 col-xs-offset-9"><a href=/en/>English</a></div></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>NodeJS 内存泄漏检测与定位</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2019-11-10 00:00:00 UTC">10 Nov 2019</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://joway.io/>@Joway</a></div></div></div></header><div class="post-content markdown-body"><p>最近解决了一个 Node.JS 应用内存泄漏 Bug，顺便学会了用 Chrome DevTools 去看 heapdump 文件。这里做一些简单的记录。<h1 id=如何优雅地获得-heapdump-文件>如何「优雅地」获得 heapdump 文件</h1><p>由于我们所有应用都是以容器部署的，所以要去获得某个容器内的文件，并拷贝到本地难度还是比较大，也非常麻烦。考虑到调试时或许会需要下载非常多次的 snapshot 文件，建议可以包下 <a href=https://www.npmjs.com/package/heapdump>heapdump</a> 库，做成一个接口，把文件 dump 之后再传输给客户端，这样一劳永逸。<p>需要小心的是，在 heapdump 的时候内存很容易翻倍，所以当内存超过 500 MB的时候如果去 heapdump 非常容易导致 OOM 从而 Crash。<h1 id=如何检测内存泄漏>如何检测内存泄漏</h1><p>检查内存泄漏有两种方法，一种是针对比较大的内存泄漏可以直接观察内存是否一直在稳步上升。如果是一些小的泄漏使得内存上升变化并不非常明显的话，可以通过对比不同时间的 heapdump 文件。<p>有时候内存上升也可能是因为本身访问量就在上升，所以需要两者对比着分析。<h2 id=heapdump-文件对比>Heapdump 文件对比</h2><p>通过下载两份间隔一段时间(几分钟)的 heapdump 文件，打开 Chrome DevTools，进入 Memory Tab，选择 Load。选中其中时间更近的 heapdump ，并选择 Comparison，比较对象是老的那份 heapdump：<p><img src=/images/nodejs-debug/01.png alt><p>此时可以选择按 Delta 排序，可以看到两个时间点增加了哪些新的对象。<p>如图可以看到 string 和 Object 的 Delta 是差不多的，所以可以比较确定是由于 Object 里产生了大量一些 string 对象导致的数量增多，但并不一定能够100%确定是内存泄漏，也可能是正常业务波动。此时需要再拉新的一个时间点的 heapdump 文件再来对比，如果一直在增加，那么内存泄漏的可能性就非常大了。<h1 id=如何定位内存泄漏>如何定位内存泄漏</h1><p>首先依旧是拿到 heapdump 文件，并在 Chrome 中打开。<p><img src=/images/nodejs-debug/02.png alt><p>这里有一些名词需要解释含义：<ul><li>Distance: 距离 GC 跟节点的距离<li>Objects Count: 对象数目<li>Shallow Size: 对象自身被创建时，在堆上申请的大小<li>Retained Size: 把此对象从堆上移除，FullGC 能够释放的空间大小</ul><p>我们可以先不管别的值，只看 <code>Retained Size</code> 。从上图我们可以看到，Object 的 <code>Retained Size</code> 是最大的，所以可以点开浏览它里面的元素。<p><img src=/images/nodejs-debug/03.png alt><p>如图标红的是该元素的引用关系，即在代码 <code>[engine.io/lib/server.js](http://engine.io/lib/server.js)</code> 中 <code>nsps(Server)</code> 对象的 <code>/notification</code> 属性下的 <code>adapter(Namespace)</code> 属性里的 <code>sids</code> 属性中引用了我们选中的对象 72257。sids 的值就是选中的对象。<p>通过查看这个对象，我们能够发现是否存在异常的内容，而通过 Retainers 里的引用关系，我们能够找到该对象在代码中的定位。如果值的内容并无异常，那有可能是 Retainers 里的引用关系导致它一直没有被释放。<p>此处很难总结出什么方法论，但主要思想就是根据 Retained Size 递减排序一路找下去。只要是内存泄漏， Retained Size 一定是会高，但反过来 Retained Size 高不一定是内存泄漏，依照这个逻辑，顺藤摸瓜总能找到一些蛛丝马迹。</div><div class="row middle-xs"><div class=col-xs-12><div class=post-category><a href=/categories/%e6%8a%80%e6%9c%af/>技术</a></div></div></div><div class=row><div class=col-xs-12><br><br><p>及时收到文章更新，请订阅：<a target=_blank href=https://mailchi.mp/a1a0d59e7a19/joway><b>Mailchimp</b></a></p><br><a rel=license href=http://creativecommons.org/licenses/by-nc-nd/4.0/><img alt="Creative Commons License" style=border-width:0 src=https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png></a></div></div><div class=post-ads><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-6400651395935595 data-ad-slot=5705651853 data-ad-format=auto data-full-width-responsive=true></ins></div><div style=height:50px></div><div class=post-comments><div id=disqus_thread></div><script>window.addEventListener("load",()=>{(function(){var d=document,s=d.createElement("script");s.src="https://joway.disqus.com/embed.js";s.setAttribute("data-timestamp",+new Date());(d.head||d.body).appendChild(s);})();});</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div><div class=site-footer><div class=site-footer-item><a href=https://mailchi.mp/a1a0d59e7a19/joway target=_blank>Subscribe</a></div><div class=site-footer-item><a href=/index.xml target=_blank>RSS</a></div><div class=site-footer-item><a href=/travel target=_blank>Travel</a></div><div class=site-footer-item><a href=https://joway.io target=_blank>About</a></div></div></div></div></article><script src=https://cdn.jsdelivr.net/gh/joway/blog/js/highlight.pack.js></script><script src=https://cdn.jsdelivr.net/gh/joway/blog/js/lazyload.min.js></script><script>var lazyImage=new LazyLoad({container:document.getElementById('article')});</script><script>hljs.initHighlightingOnLoad();</script><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script>