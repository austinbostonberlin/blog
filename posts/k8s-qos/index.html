<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hugo 0.51"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="Joway Wang"><meta property="og:url" content="https://blog.joway.io/posts/k8s-qos/"><title>Kubernetes QOS 服务质量保证 - Joway&#39;s Blog</title><meta property="og:title" content="Kubernetes QOS 服务质量保证 - Joway&#39;s Blog"><meta property="og:type" content="article"><meta name="description" content=""><link rel="stylesheet" href="/css/flexboxgrid.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/github-md.css"><link rel="stylesheet" href="/css/highlight/tomorrow-night.css"><link href="/index.xml" rel="alternate" type="application/rss+xml" title="Joway&#39;s Blog"></head><body><article class="post"><div class="row"><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"><a href="https://blog.joway.io/"><div class="head-line"></div></a><header class="post-header"><h1 class="post-title">Kubernetes QOS 服务质量保证</h1><div class="row"><div class="col-xs-6"><time class="post-date" datetime="2017-05-28 00:00:00 UTC">28 May 2017</time></div><div class="col-xs-6"><div class="post-author"><a target="_blank" href="https://joway.io/">@Joway Wang</a></div></div></div></header><div class="post-content markdown-body"><p>kubernetes 的 QOS 策略非常复杂且难以理解 , 它的文档也是在一个代码库的角落里 , 官方似乎也并不特别去强调这个功能。但在实践中 , 这种基本的功能又是不可或缺的。相关代码在 <a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/api/v1/helper/qos/qos.go">qos.go</a></p><h3 id="对于可压缩-compressible-资源">对于可压缩(Compressible) 资源</h3><p>目前仅支持 CPU 。</p><p>container 被确保拥有 requests 的资源 , 但能额外再使用多少CPU资源取决于其它 containers。例如:</p><pre><code>containerA.requests.cpu = 600m
containerB.requests.cpu = 300m
600:300 = 2:1 
=&gt;
所以 containerA 的可以被分配的额外 cpu 为 66.6， containerB 为 33.3 。
</code></pre><h3 id="不可压缩-incompressible-资源">不可压缩(Incompressible)资源</h3><p>目前仅支持 内存</p><h3 id="调度">调度</h3><p>k8s 确保一个 Pods 里的 containers 的 requests 总和会小于被分配到的Node的可用资源 , 否则则报错。</p><p>Pod 的 schedule 取决于 requests , 而非 limit。</p><p>PS : 调度在 Pod 层面上执行。</p><h3 id="qos-等级">QoS 等级</h3><blockquote><p>Best-Effort &lt; Burstable &lt; Guaranteed</p></blockquote><p><img src="https://cdn.joway.io/images/upload/14959675747.png" alt=""></p><ul><li>BestEffort: &gt; POD 中的所有容器都没有指定CPU和内存的requests和limits 例如: containers: name: foo resources: name: bar resources: 当 Node Out Of Memory 时 , 首先被杀。 当资源充足时，它可以使用全部剩余内存资源。</li><li>Burstable: &gt; POD 中只要有一个容器，这个容器requests和limits的设置同其他容器设置的不一致，那么这个POD的QoS就是Burstable级别 当limit没设置时, 默认可以达到机器最大资源数。 Burstable 当受到系统内存压力时 , 且没有 Best-Effort pod 存在时， 超出 requests 的 Pod 会被删除。 当资源充足时，它仅仅只会按照 requests 和 limits 的设置来使用内存。</li><li>Guaranteed: &gt; POD 中所有容器都必须统一设置了limits，如果有一个容器要设置requests，那么所有容器都要设置，并设置参数同limits一致。 containers: name: foo resources: limits: cpu: 10m memory: 1Gi requests: cpu: 10m memory: 1Gi name: bar resources: limits: cpu: 100m memory: 100Mi requests: cpu: 100m memory: 100Mi 若机器出现 OOM , 当没有更低优先级的时候, 再去杀它。 若Pod 自身超出了 limit ， 被杀掉。 当资源充足时，它仅仅只会按照 requests 和 limits 的设置来使用内存。</li></ul></div><div class="post-comments"><div id="disqus_thread"></div><script>(function() {
    
    var d = document,
      s = d.createElement("script");
    s.src = "https://joway.disqus.com/embed.js";
    s.setAttribute("data-timestamp", +new Date());
    (d.head || d.body).appendChild(s);
  })();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div></div></article><script src="/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>